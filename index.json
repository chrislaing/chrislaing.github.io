[{
    "title": "Odds and Ends #4",
    "date": "",
    "description": "Kops, podcasts, and Milvus.",
    "body": " I just discovered kops, apparently an excellent way to deploy and manage Kubernetes clusters on the cloud. Since managing a k8s cluster seems to be a full-time job at the best of times, I\u0026rsquo;m interested to see if this really does make it much easier. I have a very mild case of podcast addiction, and am always looking for something great to add to my collection of subscriptions. Nikita Voloboev has published a very interesting list of podcasts. I have tried a few of the ones I didn\u0026rsquo;t already know, and they are excellent. Speaking of podcasts, I highly recommend The Dropout, the result of a three-year investigation by ABC News into the fraud perpetrated by Elizabeth Holmes and her company Theranos. Milvus is a welcome new addition to the space of vector search. Vector similarity search is extremely useful any time you are dealing with high-dimensional embeddings, and it has been my observation that thinking about embeddings often leads to new and interesting opportunities quite orthogonal to the original use case for which the embeddings were produced.  ",
    "ref": "/blog/odds-and-ends-4/"
  },{
    "title": "Odds and Ends #3",
    "date": "",
    "description": "Karothek, Jupyter on K8s, and more.",
    "body": " My former colleagues at Blue Yonder (now part of JDA) have introduced Kartothek, software for managing tables stored as parquet files. A great set of documentation on going zero to JupyterHub with Kubernetes. A related piece from Jim Crist on installing JupyterHub on an existing Hadoop cluster. An interesting paper interoducing PATE from a couple of years ago that had passed me by. PATE stands for Private Aggregation of Teacher Ensembles, and is a method for doing semi-supervised transfer learning from private data.  ",
    "ref": "/blog/odds-and-ends-3/"
  },{
    "title": "Odds and Ends #2",
    "date": "",
    "description": "Information theory, an AI Playbook, and Traces.",
    "body": " Naftali Tishby on the Information Theory of Deep Learning (embedded below). I\u0026rsquo;m very enthusiastic about this kind of work, and have resolved to find and read more of it. a16z\u0026rsquo;s AI Playbook may be a couple of years old now, but it\u0026rsquo;s still an important read. Traces is a Python library for unevenly-spaced time series analysis. I haven\u0026rsquo;t had a problem to really try this out on, but the website looks slick üëåüèª.    ",
    "ref": "/blog/odds-and-ends-2/"
  },{
    "title": "Odds and Ends #1",
    "date": "",
    "description": "Spektral, RPC Frameworks, and Python packaging",
    "body": " Spektral is a framework for relational representation learning, built in Python and based on the Keras API. The field of Geometric Deep Learning is starting to get some traction. In particular, doing Deep Learning on graphs presents some interesting possibilities. RPC Frameworks: gRPC vs Thrift vs RPyC for python. The state of Python Packaging. Packing in Python is both improving dramatically and harder than it should be.  ",
    "ref": "/blog/odds-and-ends-1/"
  },{
    "title": "Keybase: Keys for everyone! Part II",
    "date": "",
    "description": "",
    "body": "In a previous post, we discussed Keybase, a clever company that is solving a lot of the classic problems that users have had with PGP: managing keys, verifying identities, trusting third parties, and user experience.\nI also mentioned that Keybase insures iteself against an attack on its servers by writing the root of its Merkle tree into the blockchain. In this post, we\u0026rsquo;ll explore what this means, and go through the process of verifying this ourselves step-by-step.\nBefore we rush ahead to the verification, let\u0026rsquo;s take a moment to understand what a Merkle root is, and why Keybase is using them.\nSuppose that we have some discrete blocks of data, and that we would like to be able to verify the integrity of these data. Concretely, let\u0026rsquo;s suppose that every time I do something on Keybase, such as verify myself on some social media account or revoke a device key, Keybase creates a JSON file which describes this activity, and stores this on its servers. Another user of Keybase can then go to Keybase\u0026rsquo;s servers and collect this JSON blob from them, in order to verify my public activity. To be even more precise, the data that the other user really wants is my signature chain; a cryptographically signed chain that records my activity.\nHowever, there\u0026rsquo;s a problem. Servers are notoriously hackable, and if someone were to compromise Keybase\u0026rsquo;s server, I could be downloading a JSON file that is telling me any old lies. Now, a compromised server\u0026rsquo;s ability to lie is dramatically restricted by the fact that any user can verify the signature chain themselves, checking external social media sites for the claimed proofs. However, a compromised server would be able to show different versions of the server state to different users.\nThis is where the Merkle tree enters the equation. A Merkle tree takes each of the pieces of data we would like to verify, the \u0026ldquo;leaves\u0026rdquo; of the tree, and hashes them. Several of these hashes are then collected together according to a defined algorithm, and the concatenation of them is then itself hashed. These concatenations are then also grouped and hashed, and so on. This heirarchical grouping forms a tree, with each concatenated hash forming a node of the tree. Eventually, we end up with one final, concatenated hash. This hash is the root of the tree. Once in possession of the root hash and the algorithm used to group and concatenate the hashes, we can verify the state of every single leaf node at the point in time that they were hashed, giving us a picture of a consistent server state. All that is needed now is for us to be able to trust the root hash of the Merkle tree, which is achieved by signing the root hash with a private key.\nThe utility of a Merkle tree for keybase now becomes obvious. This system is, however, potentially vulnerable to a sophisticated \u0026ldquo;forking\u0026rdquo; attack. One example of such an attack might be that I revoke a compromised key, and publish this change to the comprimised Keybase server. The attacker chooses not to present an updated version of the Merkle tree to another user, and exploits his lack of knowledge of my published revokation.\nKeybase solves this problem by writing the root of the Merkle tree to the Bitcoin blockchain by sending bitcoins from a known address to another. Instead of using the bitcoins, Keybase is using 160 bits of the receiving address to encode the root hash of the Merkle tree. To be a little more precise, Keybase generates a Merkle tree, then signs the root hash of the tree with its private key. It then generates a 160-bit hash of this signature, and sends Bitcoins from their address to the address represented by this hash. Once we know the address receiving the Bitcoins, we can compare the root hash of the Merkle tree presented to us by Keybase\u0026rsquo;s servers to that stored in the blockchain, rendering the forking attack useless.\n Let\u0026rsquo;s go through this process step by step, pausing where appropriate to make sure that we really understand what\u0026rsquo;s going on. We\u0026rsquo;ll use Python 3.5 to do this, partly because it is my language of choice for most tasks, but mostly because the original keybase security documentation uses Python, albeit version 2.7. Let me be clear right from the outset that the code is taken almost entirely from the keybase security documentation, and credit for it should be attributed to the Keybase team. My contribution is limited to making the code work with Python 3.5, and a few cosmetic edits for legibility.\nWe start by importing the packages that we\u0026rsquo;ll need.\nimport requests, datetime, json, re, gnupg from base64 import b64decode from pycoin.encoding import bitcoin_address_to_hash160_sec, hash160 from binascii import hexlify from hashlib import sha512, sha256 Recall that what we need to find is the 160-bit hash of the signed root of the Keybase Merkle tree, which is stored in the blockchain as the receiving address for the latest transaction from the sending address 1HUCBSJeHnkhzrVKVjaVmWg2QtZS1mdfaz. Without downloading the multi-gigabyte Bitcoin blockchain in its entirity, the easiest way to find this address is to query blockchain.info using the requests library. Requests is a beautifully written python library, that is often cited as the gold standard for clean, pythonic APIs. I recommend learning to use its basic functionality even for simple cases such as ours.\nWe use a simple GET request to query the blockchain.info API.\nfrom_addr = \u0026#34;1HUCBSJeHnkhzrVKVjaVmWg2QtZS1mdfaz\u0026#34; uri = \u0026#34;https://blockchain.info/address/%s?format=json\u0026#34; % (from_addr) r = requests.get(uri) to_addr = r.json()[\u0026#39;txs\u0026#39;][0][\u0026#39;out\u0026#39;][0][\u0026#39;addr\u0026#39;] to_addr_hash = hexlify(bitcoin_address_to_hash160_sec(to_addr)).decode(\u0026#39;utf-8\u0026#39;) print(to_addr_hash) 1eeea91d88d3578e3e718fa97da8ec79d7227304 Notice that we have decoded the string from UTF-8. We will see this decoding and encoding of strings to and from UTF-8 appears several times as we progress. The difference from the keybase.io example arises because of the different way that Python 3.5 handles strings, and the encoding expectations of the different libraries that we are using.\nGiven that our code varies from that presented on keybase.io, it would be reasonable to ask whether this encoding and decoding in some way invalidates the verification that we are undertaking. These processes merely alter the representation of the string, not its content. It is not the string object as it appears in computer memory that we are verifying, but the evaluated content of the string. Theoretically, we could even perform the verification process by hand, separating the content of the string entirely from its representation in computer memory. We are therefore on farily safe ground.\nThe variable to_addr_hash now contains a hexadecimal hash, which corresponds to a root block on the Keybase servers. We can query the Keybase API to find that block.\nkb = \u0026#34;https://keybase.io/_/api/1.0\u0026#34; uri = \u0026#34;%s/merkle/root.json?hash160=%s\u0026#34; % (kb, to_addr_hash) r = requests.get(uri) root_desc = json.loads(r.text) The root_desc variable now holds a JSON file full of information about the root block. What we need is the signature of the hash of the root block, which is contained in the sig field. Noting again the string encoding and decoding, we use a regular expression to extract the signature itself from the surrounding ASCII armouring, and verify with an assert statement that the hexadecimal hash of the signature matches the hexadecimal hash of the receiving bitcoin address that we found in the first step.\nsig = b64decode(re.compile(r\u0026#34;\\n\\n((\\S|\\n)*?)\\n=\u0026#34;).search(root_desc[\u0026#39;sig\u0026#39;]).group(1).encode(\u0026#39;utf-8\u0026#39;, \u0026#39;ignore\u0026#39;)) if to_addr_hash == hexlify(hash160(sig)).decode(\u0026#39;utf-8\u0026#39;, \u0026#39;ignore\u0026#39;): print(\u0026#34;We have the correct block.\u0026#34;) else: print(\u0026#34;Oops, wrong block!\u0026#34;) We have the correct block. Recall that this hash is not the root hash itself. Rather, it is the 160-bit hash of the Keybase PGP signature of the root hash. This makes sense, as we would like to be sure not just that the Merkle tree is intact, but that Keybase has verified it as being correct.\nKeybase\u0026rsquo;s Merkle key has the fingerprint 03E146CDAF8136680AD566912A32340CEC8C9492, and is imported into my GPG keyring. The gnupg python package allows us to inspect this signature and verify it.\ngpg = gnupg.GPG() verified = gpg.verify(sig) print(\u0026#39;Signed by {0},\\nwith public key fingerprint {1},\\non {2}.\\n\u0026#39;.format(verified.username, verified.pubkey_fingerprint, datetime.datetime.utcfromtimestamp( float(verified.sig_timestamp)) .strftime(\u0026#39;%d/%m/%Y\u0026#39;))) if verified.valid: print(\u0026#39;Signature is valid.\u0026#39;) else: print(\u0026#39;Signature invalid!\u0026#39;) Signed by Keybase.io Merkle Signing (v1) \u0026lt;merkle@keybase.io\u0026gt;, with public key fingerprint 03E146CDAF8136680AD566912A32340CEC8C9492, on 20/02/2017. Signature is valid. Now we know that not only is the Merkle tree is intact, but that Keybase has verified it as being correct, and when they did so. The signature object contains the root hash of the root block of the Merkle tree. We can use another regular expression to find it.\nroot_hash = json.loads(re.compile(r\u0026#34;({[\\x00-\\x7f]*})\u0026#34;).search(sig.decode(\u0026#39;utf-8\u0026#39;, \u0026#39;ignore\u0026#39;)).group(1))[\u0026#39;body\u0026#39;][\u0026#39;root\u0026#39;] print(\u0026#39;Root block hash: %s\u0026#39; % root_hash) Root block hash: 55a8731fdb7141f0e8441d01f0431624de9d275952e7dcb19bb35088a0e5cf90312c67cb0fc876a5a888b61fa545c1261bc2732ac2d759e6f9488b30ff902f28 Now that we have the hash of the root block, let\u0026rsquo;s check that the Keybase server wasn\u0026rsquo;t lying to us about the contents of the block.\nuri = \u0026#34;%s/merkle/block.json?hash=%s\u0026#34; % (kb, root_hash) value_string = requests.get(uri).json()[\u0026#39;value_string\u0026#39;] computed_hash = hexlify(sha512(value_string.encode(\u0026#39;utf-8\u0026#39;)).digest()).decode(\u0026#39;utf-8\u0026#39;) if computed_hash == root_hash: print(\u0026#39;Root hash and computed hash match.\u0026#39;) else: print(\u0026#39;Root hash: %s,\\n\u0026#39;%root_hash, \u0026#39;Computed hash: %s\u0026#39;%computed_hash) Root hash and computed hash match. Let\u0026rsquo;s pause and think about what we\u0026rsquo;ve discovered. We know that Keybase created a Merkle tree, which encodes the exact status of every user\u0026rsquo;s signature chain at the time that the tree was written. The root hash of this tree was then signed by Keybase, and then this signature was hashed and written into the blockchain.\nTo verify this, we walked backwards through the process. We went to the blockchain and found the latest hash, and asked Keybase for the signed Merkle tree corresponding to this hash. We verified that the hash of this signature corresponded to the hash that we found in the blockchain, and then verified that the signature came from Keybase. Having done that, we checked that the hash we were given is correct by computing the hash ourselves, and comparing the two.\nWe can now descend the Merkle tree to find the last thing I signed into my sigchain. You can use any user, as this is public information (indeed, that\u0026rsquo;s the point!), so try your own.\nusername = \u0026#34;chrislaing\u0026#34; uri = \u0026#34;%s/user/lookup.json?username=%s\u0026#34; % (kb, username) r = requests.get(uri) uid = r.json()[\u0026#39;them\u0026#39;][\u0026#39;id\u0026#39;] Let\u0026rsquo;s define a couple of helper functions to make descending the tree easier. The trees are written in such a way that the JSON string returned by the API has as keys the first few characters of the hash. The method I use in traverse_tree is actually quite ugly, as it simply checks each potential key length until it finds a match. The data is so small, however, that I didn\u0026rsquo;t see the need to write a prettier way of doing it - if you\u0026rsquo;d like to do this, then please leave a comment, and I\u0026rsquo;ll update the post.\ndef traverse_tree(start_hash): uri = \u0026#34;%s/merkle/block.json?hash=%s\u0026#34; % (kb, start_hash) value_string = requests.get(uri).json()[\u0026#39;value_string\u0026#39;] computed_hash = hexlify(sha512(value_string.encode(\u0026#39;utf-8\u0026#39;)).digest()).decode(\u0026#39;utf-8\u0026#39;) assert(computed_hash == start_hash) tab = json.loads(value_string)[\u0026#39;tab\u0026#39;] for i in range(len(uid)+1): if uid[:i] in tab.keys(): print(\u0026#39;key length %dof %d\u0026#39;%(i, len(uid))) nxt = tab[uid[:i]] if i == len(uid): return nxt[1][1] else: return nxt def verify_link_hash(link_hash): uri = \u0026#34;%s/sig/get.json?uid=%s\u0026#34; % (kb, uid) payload = requests.get(uri).json()[\u0026#39;sigs\u0026#39;][-1][\u0026#39;payload_json\u0026#39;] computed_hash = hexlify(sha256(payload.encode(\u0026#39;utf-8\u0026#39;)).digest()).decode(\u0026#39;utf-8\u0026#39;) return (computed_hash == link_hash.encode(\u0026#39;utf-8\u0026#39;)) def get_computed_hash(uid): uri = \u0026#34;%s/sig/get.json?uid=%s\u0026#34; % (kb, uid) payload = requests.get(uri).json()[\u0026#39;sigs\u0026#39;][-1][\u0026#39;payload_json\u0026#39;] computed_hash = hexlify(sha256(payload.encode(\u0026#39;utf-8\u0026#39;)).digest()).decode(\u0026#39;utf-8\u0026#39;) return computed_hash def get_payload(uid): uri = \u0026#34;%s/sig/get.json?uid=%s\u0026#34; % (kb, uid) payload = requests.get(uri).json()[\u0026#39;sigs\u0026#39;][-1][\u0026#39;payload_json\u0026#39;] return payload The idea is very simple. Using my user ID, we query the Keybase api for the last action that I signed into my sigchain. To verify that this exists in the version of the Merkle tree that we verified above, we walk down the Merkle tree, progressively querying the Keybase API for each new node, and then comparing the hash of what Keybase tells us to the hash we expect. In this way, we verify all the contents of the Merkle tree from the root, down the branches that lead to my leaf, until we arrive at my leaf block itself.\nlink_hash = root_hash computed_hash = get_computed_hash(uid) while link_hash != computed_hash: link_hash = traverse_tree(link_hash) if link_hash == computed_hash: print(\u0026#39;Leaf node found in the Merkle tree.\u0026#39;) else: print(\u0026#39;Leaf node is not part of the Merkle tree!\u0026#39;) key length 1 of 32 key length 2 of 32 key length 3 of 32 key length 4 of 32 key length 32 of 32 Leaf node found in the Merkle tree. Now that we know that the server state that Keybase is reporting to us is correct, consistent, and signed by Keybase, we can inspect the payload we got from the API to see what I actually did.\njson.loads(get_payload(uid)) { \u0026#39;body\u0026#39;:{ \u0026#39;key\u0026#39;:{ \u0026#39;eldest_kid\u0026#39;:\u0026#39;0101c0eab8dc42e80f0a754adc7d5504249ca3dc2d6c848407e6e148729c800a25010a\u0026#39;, \u0026#39;host\u0026#39;:\u0026#39;keybase.io\u0026#39;, \u0026#39;kid\u0026#39;:\u0026#39;0120d945e916db5015ff9e8d5605e822e3808c90602a043fe08aa43b91449a5de6b40a\u0026#39;, \u0026#39;uid\u0026#39;:\u0026#39;4ac28b770f9cd1199981621a42eac000\u0026#39;, \u0026#39;username\u0026#39;:\u0026#39;chrislaing\u0026#39; }, \u0026#39;service\u0026#39;:{ \u0026#39;name\u0026#39;:\u0026#39;reddit\u0026#39;, \u0026#39;username\u0026#39;:\u0026#39;laing_c\u0026#39; }, \u0026#39;type\u0026#39;:\u0026#39;web_service_binding\u0026#39;, \u0026#39;version\u0026#39;:1 }, \u0026#39;client\u0026#39;:{ \u0026#39;name\u0026#39;:\u0026#39;keybase.io go client\u0026#39;, \u0026#39;version\u0026#39;:\u0026#39;1.0.18\u0026#39; }, \u0026#39;ctime\u0026#39;:1487579548, \u0026#39;expire_in\u0026#39;:504576000, \u0026#39;merkle_root\u0026#39;:{ \u0026#39;ctime\u0026#39;:1487579413, \u0026#39;hash\u0026#39;:\u0026#39;f37e1e249b16110bb5ad4fdaba7cc044ee86ce6aae1efb1c51eedf6ca9d955a6cd400e19dc9211e68ad9cf74a4b2082aa767c831ff625417a936e82b6d6857fd\u0026#39;, \u0026#39;seqno\u0026#39;:907120 }, \u0026#39;prev\u0026#39;:\u0026#39;bf84e1e3dd41765dd105ee814bc4b81dcba6a3988f5c12896b56ab2d430ecb9b\u0026#39;, \u0026#39;seqno\u0026#39;:45, \u0026#39;tag\u0026#39;:\u0026#39;signature\u0026#39; } In this case, I proved my reddit identity, laing_c. The JSON blob also contains lots of useful details about the proof, such as the time that I signed it, the details of the client used to sign the proof, and so on.\nIn case you\u0026rsquo;re curious, here\u0026rsquo;s the proof.\n Now we know how to verify that Keybase hasn\u0026rsquo;t been taken over by a malicious third party, who is seeking to lie to us - either actively or by omission - about the state of the Keybase server.\nI really applaud the team at Keybase for going to this extent. It\u0026rsquo;s fantastic that they have managed to combine a very accessible day-to-day user experience with a completely open and verifiable trust system. I haven\u0026rsquo;t even touched on some of the other magic they\u0026rsquo;ve been working, such as the Keybase file system, but I might come to that in a future post.\nI hope that you enjoyed this little walk through the Keybase blockchain verification system, and that you found it somewhat helpful in understanding how Keybase works.\n",
    "ref": "/blog/keybase-keys-for-everyone-part-ii/"
  },{
    "title": "Keybase: Keys for everyone! Part I",
    "date": "",
    "description": "",
    "body": " Encryption is a topic that has fascinated me for years, less because of its mathematical basis than its applications, both existing and potential. By far my favourite project in this realm is Keybase.\nKeybase cleverly solves several major problems with PGP-based encryption technology by taking the attitude that online, your identity is functionally the sum of your online profiles. With Keybase, you can automatically verify that @cjlaing on twitter has a particular key, and can encrypt messages or files for him without having to ascertain and validate his key through some other medium. The client software is open source, and works seamlessly with both PGP and NaCl keys.\nOne of the truly excellent features of Keybase\u0026rsquo;s design is its trust model; although their website and file hosting service offers a centralised interface, that interface is entirely orthogonal to the operation of the service. When you want to id someone and verify their key (me, for example), the Keybase client goes to each of their listed web identities, finds the proof, and verifies it, without needing to trust the keybase.io website at all. Every time a user verifies someone\u0026rsquo;s identity by tracking them, this proof is written into the blockchain. The entire chain can then be independently verified, without requiring anyone to trust Keybase itself.\nThe Keybase filesystem is an extremely clever extension of the core Keybase concept. What I find most interesting is the idea that, in principle, data can be securely shared with someone who hasn\u0026rsquo;t yet signed up for Keybase, whom you know purely through one of their online identities. When they join Keybase and prove their ownership of that identity, your client will verify the proof and encrypt the file for them.\nKeybase is still in an invitation-only testing phase, however they already have over 100,000 users as of the time of writing. The project is bringing a lot of great new ideas together with solid, tried, and tested cryptography, and I\u0026rsquo;m excited to see where the project goes next.\nIn Part II of this post, we\u0026rsquo;ll take a look at how to verify Keybase proofs yourself, and traverse a user\u0026rsquo;s cryptographic chain using Python.\n",
    "ref": "/blog/keybase-keys-for-everyone-part-i/"
  },{
    "title": "A New Hope",
    "date": "",
    "description": "",
    "body": "Many years ago, I had a blog. Being perfectly honest, it wasn\u0026rsquo;t a very good blog; it consisted mainly of rants of one kind or another, inane musings, and the occasional photo from my holidays. On the modern web, social media is the default depository for said rants, musings, and photos, and so I had no need of a dedicated space on my website to share them.\nHowever, it occurred to me recently that I now share quite a bit of material relating to my work and academic interests; blog posts, interesting new projects, snippets of code, or more general articles related to science and technology. I distribute these nuggets of enlightenment primarily through closed channels - slack, hangouts, messaging apps - with the sole exception of twitter, depriving my many adoring fans of interesting material, and me of feedback.\nSo today, my blog is now open again for business, this time with (hopefully) fewer boring political rants, and more interesting links. I hope that you will find it to be of some interest.\n",
    "ref": "/blog/a-new-hope/"
  },{
    "title": "About Me",
    "date": "",
    "description": "",
    "body": " About me I\u0026rsquo;m Christopher. I live in Wellington, New Zealand, and work at a specialist data firm where I am the Director of Artificial Intelligence and Data Science.\n I received my PhD in Applied Mathematics, as well as my undergraduate degrees in Law and Mathematics, from the University of Otago.\nMy doctoral thesis, entitled Numerical Construction of Static Fluid Interfaces with the Embedding Formalism, is an attempt to reformulate the Young-Laplace equation for static fluid interfaces in the language of differential geometry, and to devise a numerical implementation for the system by Finite Elements.\nMy thesis is available for download from the University of Otago OUR Archive.\n",
    "ref": "/about/"
  }]
