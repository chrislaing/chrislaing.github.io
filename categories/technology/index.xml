<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>technology on chrislaing.net</title>
    <link>http://chrislaing.net/categories/technology/index.xml</link>
    <description>Recent content in technology on chrislaing.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://chrislaing.net/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Keybase: Keys for everyone! Part II</title>
      <link>http://chrislaing.net/blog/keybase-keys-for-everyone-part-ii/</link>
      <pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://chrislaing.net/blog/keybase-keys-for-everyone-part-ii/</guid>
      <description>&lt;p&gt;In a &lt;a href=&#34;http://chrislaing.net/blog/keybase-keys-for-everyone-part-i/&#34;&gt;previous post&lt;/a&gt;, we discussed &lt;a href=&#34;https://keybase.io&#34;&gt;Keybase&lt;/a&gt;, a clever company that is solving a lot of the classic problems that users have had with PGP: managing keys, verifying identities, trusting third parties, and user experience.&lt;/p&gt;

&lt;p&gt;I also mentioned that Keybase insures iteself against an attack on its servers by writing the root of its Merkle tree into the blockchain. In this post, we&amp;rsquo;ll explore what this means, and go through the process of verifying this ourselves step-by-step.&lt;/p&gt;

&lt;p&gt;Before we rush ahead to the verification, let&amp;rsquo;s take a moment to understand what a Merkle root is, and why Keybase is using them.&lt;/p&gt;

&lt;p&gt;Suppose that we have some discrete blocks of data, and that we would like to be able to verify the integrity of these data. Concretely, let&amp;rsquo;s suppose that every time I do something on Keybase, such as verify myself on some social media account or revoke a device key, Keybase creates a JSON file which describes this activity, and stores this on its servers. Another user of Keybase can then go to Keybase&amp;rsquo;s servers and collect this JSON blob from them, in order to verify my public activity. To be even more precise, the data that the other user really wants is my signature chain; a cryptographically signed chain that records my activity.&lt;/p&gt;

&lt;p&gt;However, there&amp;rsquo;s a problem. Servers are notoriously hackable, and if someone were to compromise Keybase&amp;rsquo;s server, I could be downloading a JSON file that is telling me any old lies. Now, a compromised server&amp;rsquo;s ability to lie is dramatically restricted by the fact that any user can verify the signature chain themselves, checking external social media sites for the claimed proofs. However, a compromised server would be able to show different versions of the server state to different users.&lt;/p&gt;

&lt;p&gt;This is where the Merkle tree enters the equation. A Merkle tree takes each of the pieces of data we would like to verify, the &amp;ldquo;leaves&amp;rdquo; of the tree, and hashes them. Several of these hashes are then collected together according to a defined algorithm, and the concatenation of them is then itself hashed. These concatenations are then also grouped and hashed, and so on. This heirarchical grouping forms a tree, with each concatenated hash forming a node of the tree. Eventually, we end up with one final, concatenated hash. This hash is the root of the tree. Once in possession of the root hash and the algorithm used to group and concatenate the hashes, we can verify the state of every single leaf node at the point in time that they were hashed, giving us a picture of a consistent server state. All that is needed now is for us to be able to trust the root hash of the Merkle tree, which is achieved by signing the root hash with a private key.&lt;/p&gt;

&lt;p&gt;The utility of a Merkle tree for keybase now becomes obvious. This system is, however, potentially vulnerable to a sophisticated &amp;ldquo;forking&amp;rdquo; attack. One example of such an attack might be that I revoke a compromised key, and publish this change to the comprimised Keybase server. The attacker chooses not to present an updated version of the Merkle tree to another user, and exploits his lack of knowledge of my published revokation.&lt;/p&gt;

&lt;p&gt;Keybase solves this problem by writing the root of the Merkle tree to the Bitcoin blockchain by sending bitcoins from a known address to another. Instead of using the bitcoins, Keybase is using 160 bits of the receiving address to encode the root hash of the Merkle tree. To be a little more precise, Keybase generates a Merkle tree, then signs the root hash of the tree with its private key. It then generates a 160-bit hash of this signature, and sends Bitcoins from their address to the address represented by this hash. Once we know the address receiving the Bitcoins, we can compare the root hash of the Merkle tree presented to us by Keybase&amp;rsquo;s servers to that stored in the blockchain, rendering the forking attack useless.&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://chrislaing.net/img/2017/02/Hash_Tree.png&#34; alt=&#34;from:https://en.wikipedia.org/wiki/Merkle_tree&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Let&amp;rsquo;s go through this process step by step, pausing where appropriate to make sure that we really understand what&amp;rsquo;s going on. We&amp;rsquo;ll use Python 3.5 to do this, partly because it is my language of choice for most tasks, but mostly because the &lt;a href=&#34;https://keybase.io/docs/server_security/merkle_root_in_bitcoin_blockchain&#34;&gt;original keybase security documentation&lt;/a&gt; uses Python, albeit version 2.7. Let me be clear right from the outset that the code is taken almost entirely from the keybase security documentation, and credit for it should be attributed to the Keybase team. My contribution is limited to making the code work with Python 3.5, and a few cosmetic edits for legibility.&lt;/p&gt;

&lt;p&gt;We start by importing the packages that we&amp;rsquo;ll need.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests, datetime, json, re, gnupg
from base64 import b64decode
from pycoin.encoding import bitcoin_address_to_hash160_sec, hash160
from binascii import hexlify
from hashlib import sha512, sha256
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall that what we need to find is the 160-bit hash of the signed root of the Keybase Merkle tree, which is stored in the blockchain as the receiving address for the latest transaction from the sending address &lt;code&gt;1HUCBSJeHnkhzrVKVjaVmWg2QtZS1mdfaz&lt;/code&gt;. Without downloading the multi-gigabyte Bitcoin blockchain in its entirity, the easiest way to find this address is to query &lt;a href=&#34;https://blockchain.info&#34;&gt;blockchain.info&lt;/a&gt; using the requests library. Requests is a beautifully written python library, that is often cited as the gold standard for clean, pythonic APIs. I recommend learning to use its basic functionality even for simple cases such as ours.&lt;/p&gt;

&lt;p&gt;We use a simple GET request to query the blockchain.info API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from_addr = &amp;quot;1HUCBSJeHnkhzrVKVjaVmWg2QtZS1mdfaz&amp;quot;
uri       = &amp;quot;https://blockchain.info/address/%s?format=json&amp;quot; % (from_addr)
r = requests.get(uri)
to_addr   = r.json()[&#39;txs&#39;][0][&#39;out&#39;][0][&#39;addr&#39;]
to_addr_hash = hexlify(bitcoin_address_to_hash160_sec(to_addr)).decode(&#39;utf-8&#39;)
print(to_addr_hash)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;1eeea91d88d3578e3e718fa97da8ec79d7227304
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we have decoded the string from UTF-8. We will see this decoding and encoding of strings to and from UTF-8 appears several times as we progress. The difference from the keybase.io example arises because of the different way that Python 3.5 handles strings, and the encoding expectations of the different libraries that we are using.&lt;/p&gt;

&lt;p&gt;Given that our code varies from that presented on keybase.io, it would be reasonable to ask whether this encoding and decoding in some way invalidates the verification that we are undertaking. These processes merely alter the representation of the string, not its content. It is not the string object as it appears in computer memory that we are verifying, but the evaluated content of the string. Theoretically, we could even perform the verification process by hand, separating the content of the string entirely from its representation in computer memory. We are therefore on farily safe ground.&lt;/p&gt;

&lt;p&gt;The variable &lt;code&gt;to_addr_hash&lt;/code&gt; now contains a hexadecimal hash, which corresponds to a root block on the Keybase servers. We can query the Keybase API to find that block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;kb        = &amp;quot;https://keybase.io/_/api/1.0&amp;quot;
uri       = &amp;quot;%s/merkle/root.json?hash160=%s&amp;quot; % (kb, to_addr_hash)
r = requests.get(uri)
root_desc = json.loads(r.text)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The root_desc variable now holds a JSON file full of information about the root block. What we need is the signature of the hash of the root block, which is contained in the &lt;code&gt;sig&lt;/code&gt; field. Noting again the string encoding and decoding, we use a regular expression to extract the signature itself from the surrounding ASCII armouring, and verify with an assert statement that the hexadecimal hash of the signature matches the hexadecimal hash of the receiving bitcoin address that we found in the first step.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sig = b64decode(re.compile(r&amp;quot;\n\n((\S|\n)*?)\n=&amp;quot;).search(root_desc[&#39;sig&#39;]).group(1).encode(&#39;utf-8&#39;, &#39;ignore&#39;))
if to_addr_hash == hexlify(hash160(sig)).decode(&#39;utf-8&#39;, &#39;ignore&#39;):
    print(&amp;quot;We have the correct block.&amp;quot;)
else:
    print(&amp;quot;Oops, wrong block!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;We have the correct block.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall that this hash is not the root hash itself. Rather, it is the 160-bit hash of the Keybase PGP signature of the root hash. This makes sense, as we would like to be sure not just that the Merkle tree is intact, but that Keybase has verified it as being correct.&lt;/p&gt;

&lt;p&gt;Keybase&amp;rsquo;s Merkle key has the fingerprint &lt;code&gt;03E146CDAF8136680AD566912A32340CEC8C9492&lt;/code&gt;, and is imported into my GPG keyring. The gnupg python package allows us to inspect this signature and verify it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;gpg = gnupg.GPG()
verified = gpg.verify(sig)

print(&#39;Signed by {0},\n with public key fingerprint {1},\n on {2}.\n&#39;.format(verified.username, 
                                                                                  verified.pubkey_fingerprint,
                                                                                 datetime.datetime.utcfromtimestamp(
                                                                                float(verified.sig_timestamp))
                                                                                  .strftime(&#39;%d/%m/%Y&#39;)))

if verified.valid:
    print(&#39;Signature is valid.&#39;)
else:
    print(&#39;Signature invalid!&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Signed by Keybase.io Merkle Signing (v1) &amp;lt;merkle@keybase.io&amp;gt;,
 with public key fingerprint 03E146CDAF8136680AD566912A32340CEC8C9492,
 on 20/02/2017.
    
Signature is valid.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we know that not only is the Merkle tree is intact, but that Keybase has verified it as being correct, and when they did so. The signature object contains the root hash of the root block of the Merkle tree. We can use another regular expression to find it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;root_hash = json.loads(re.compile(r&amp;quot;({[\x00-\x7f]*})&amp;quot;).search(sig.decode(&#39;utf-8&#39;, &#39;ignore&#39;)).group(1))[&#39;body&#39;][&#39;root&#39;]
print(&#39;Root block hash: %s&#39; % root_hash)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Root block hash: 55a8731fdb7141f0e8441d01f0431624de9d275952e7dcb19bb35088a0e5cf90312c67cb0fc876a5a888b61fa545c1261bc2732ac2d759e6f9488b30ff902f28
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have the hash of the root block, let&amp;rsquo;s check that the Keybase server wasn&amp;rsquo;t lying to us about the contents of the block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;uri = &amp;quot;%s/merkle/block.json?hash=%s&amp;quot; % (kb, root_hash)
value_string = requests.get(uri).json()[&#39;value_string&#39;]
computed_hash = hexlify(sha512(value_string.encode(&#39;utf-8&#39;)).digest()).decode(&#39;utf-8&#39;)
if computed_hash == root_hash:
    print(&#39;Root hash and computed hash match.&#39;)
else:
    print(&#39;Root hash: %s,\n&#39;%root_hash, &#39;Computed hash: %s&#39;%computed_hash)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Root hash and computed hash match.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s pause and think about what we&amp;rsquo;ve discovered. We know that Keybase created a Merkle tree, which encodes the exact status of every user&amp;rsquo;s signature chain at the time that the tree was written. The root hash of this tree was then signed by Keybase, and then this signature was hashed and written into the blockchain.&lt;/p&gt;

&lt;p&gt;To verify this, we walked backwards through the process. We went to the blockchain and found the latest hash, and asked Keybase for the signed Merkle tree corresponding to this hash. We verified that the hash of this signature corresponded to the hash that we found in the blockchain, and then verified that the signature came from Keybase. Having done that, we checked that the hash we were given is correct by computing the hash ourselves, and comparing the two.&lt;/p&gt;

&lt;p&gt;We can now descend the Merkle tree to find the last thing I signed into my sigchain. You can use any user, as this is public information (indeed, that&amp;rsquo;s the point!), so try your own.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;username = &amp;quot;chrislaing&amp;quot;
uri      = &amp;quot;%s/user/lookup.json?username=%s&amp;quot; % (kb, username)
r = requests.get(uri)
uid = r.json()[&#39;them&#39;][&#39;id&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s define a couple of helper functions to make descending the tree easier. The trees are written in such a way that the JSON string returned by the API has as keys the first few characters of the hash. The method I use in &lt;code&gt;traverse_tree&lt;/code&gt; is actually quite ugly, as it simply checks each potential key length until it finds a match. The data is so small, however, that I didn&amp;rsquo;t see the need to write a prettier way of doing it - if you&amp;rsquo;d like to do this, then please leave a comment, and I&amp;rsquo;ll update the post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def traverse_tree(start_hash):
    uri = &amp;quot;%s/merkle/block.json?hash=%s&amp;quot; % (kb, start_hash)
    value_string = requests.get(uri).json()[&#39;value_string&#39;]
    computed_hash = hexlify(sha512(value_string.encode(&#39;utf-8&#39;)).digest()).decode(&#39;utf-8&#39;)
    assert(computed_hash == start_hash)
    tab = json.loads(value_string)[&#39;tab&#39;]
    for i in range(len(uid)+1):
        if uid[:i] in tab.keys():
            print(&#39;key length %d of %d&#39;%(i, len(uid)))
            nxt = tab[uid[:i]]
            if i == len(uid):
                return nxt[1][1]
            else:
                return nxt

def verify_link_hash(link_hash):
    uri = &amp;quot;%s/sig/get.json?uid=%s&amp;quot; % (kb, uid)
    payload = requests.get(uri).json()[&#39;sigs&#39;][-1][&#39;payload_json&#39;]
    computed_hash = hexlify(sha256(payload.encode(&#39;utf-8&#39;)).digest()).decode(&#39;utf-8&#39;)
    return (computed_hash == link_hash.encode(&#39;utf-8&#39;))

def get_computed_hash(uid):
    uri = &amp;quot;%s/sig/get.json?uid=%s&amp;quot; % (kb, uid)
    payload = requests.get(uri).json()[&#39;sigs&#39;][-1][&#39;payload_json&#39;]
    computed_hash = hexlify(sha256(payload.encode(&#39;utf-8&#39;)).digest()).decode(&#39;utf-8&#39;)
    return computed_hash

def get_payload(uid):
    uri = &amp;quot;%s/sig/get.json?uid=%s&amp;quot; % (kb, uid)
    payload = requests.get(uri).json()[&#39;sigs&#39;][-1][&#39;payload_json&#39;]
    return payload        
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea is very simple. Using my user ID, we query the Keybase api for the last action that I signed into my sigchain. To verify that this exists in the version of the Merkle tree that we verified above, we walk down the Merkle tree, progressively querying the Keybase API for each new node, and then comparing the hash of what Keybase tells us to the hash we expect. In this way, we verify all the contents of the Merkle tree from the root, down the branches that lead to my leaf, until we arrive at my leaf block itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;link_hash = root_hash
computed_hash = get_computed_hash(uid)
while link_hash != computed_hash:
    link_hash = traverse_tree(link_hash)
    
if link_hash == computed_hash:
    print(&#39;Leaf node found in the Merkle tree.&#39;)
else:
    print(&#39;Leaf node is not part of the Merkle tree!&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;key length 1 of 32
key length 2 of 32
key length 3 of 32
key length 4 of 32
key length 32 of 32
Leaf node found in the Merkle tree.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we know that the server state that Keybase is reporting to us is correct, consistent, and signed by Keybase, we can inspect the payload we got from the API to see what I actually did.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;json.loads(get_payload(uid))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;{  
   &#39;body&#39;:{  
      &#39;key&#39;:{  
         &#39;eldest_kid&#39;:&#39;0101c0eab8dc42e80f0a754adc7d5504249ca3dc2d6c848407e6e148729c800a25010a&#39;,
         &#39;host&#39;:&#39;keybase.io&#39;,
         &#39;kid&#39;:&#39;0120d945e916db5015ff9e8d5605e822e3808c90602a043fe08aa43b91449a5de6b40a&#39;,
         &#39;uid&#39;:&#39;4ac28b770f9cd1199981621a42eac000&#39;,
         &#39;username&#39;:&#39;chrislaing&#39;
      },
      &#39;service&#39;:{  
         &#39;name&#39;:&#39;reddit&#39;,
         &#39;username&#39;:&#39;laing_c&#39;
      },
      &#39;type&#39;:&#39;web_service_binding&#39;,
      &#39;version&#39;:1
   },
   &#39;client&#39;:{  
      &#39;name&#39;:&#39;keybase.io go client&#39;,
      &#39;version&#39;:&#39;1.0.18&#39;
   },
   &#39;ctime&#39;:1487579548,
   &#39;expire_in&#39;:504576000,
   &#39;merkle_root&#39;:{  
      &#39;ctime&#39;:1487579413,
      &#39;hash&#39;:&#39;f37e1e249b16110bb5ad4fdaba7cc044ee86ce6aae1efb1c51eedf6ca9d955a6cd400e19dc9211e68ad9cf74a4b2082aa767c831ff625417a936e82b6d6857fd&#39;,
      &#39;seqno&#39;:907120
   },
   &#39;prev&#39;:&#39;bf84e1e3dd41765dd105ee814bc4b81dcba6a3988f5c12896b56ab2d430ecb9b&#39;,
   &#39;seqno&#39;:45,
   &#39;tag&#39;:&#39;signature&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, I proved my reddit identity, &lt;code&gt;laing_c&lt;/code&gt;. The JSON blob also contains lots of useful details about the proof, such as the time that I signed it, the details of the client used to sign the proof, and so on.&lt;/p&gt;

&lt;p&gt;In case you&amp;rsquo;re curious, &lt;a href=&#34;https://www.reddit.com/r/KeybaseProofs/comments/5v3hy8/my_keybase_proof_redditlaing_c_keybasechrislaing/&#34;&gt;here&amp;rsquo;s the proof.&lt;/a&gt;&lt;/p&gt;




    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;p&gt;&lt;span class=&#34;image center-image&#34;&gt;
            &lt;img src=&#34;http://chrislaing.net/img/2017/02/reddit_keybase_proof.png&#34; alt=&#34;My Keybase proof on Reddit&#34; /&gt;
        &lt;/span&gt;&lt;/p&gt;
    



&lt;p&gt;Now we know how to verify that Keybase hasn&amp;rsquo;t been taken over by a malicious third party, who is seeking to lie to us - either actively or by omission - about the state of the Keybase server.&lt;/p&gt;

&lt;p&gt;I really applaud the team at Keybase for going to this extent. It&amp;rsquo;s fantastic that they have managed to combine a very accessible day-to-day user experience with a completely open and verifiable trust system. I haven&amp;rsquo;t even touched on some of the other magic they&amp;rsquo;ve been working, such as the &lt;a href=&#34;https://keybase.io/docs/kbfs&#34;&gt;Keybase file system&lt;/a&gt;, but I might come to that in a future post.&lt;/p&gt;

&lt;p&gt;I hope that you enjoyed this little walk through the Keybase blockchain verification system, and that you found it somewhat helpful in understanding how Keybase works.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Keybase: Keys for everyone! Part I</title>
      <link>http://chrislaing.net/blog/keybase-keys-for-everyone-part-i/</link>
      <pubDate>Sun, 13 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://chrislaing.net/blog/keybase-keys-for-everyone-part-i/</guid>
      <description>&lt;p&gt;


    
    
        
        
        
        
    

    
    
    

    
    




    
    
        
    


    

    
        &lt;span class=&#34;image right&#34;&gt;
            &lt;img src=&#34;http://chrislaing.net/img/2016/11/chrislaing_keybase_proof_graph.png&#34; alt=&#34;Graph of Keybase proofs for Keybase user chrislaing&#34; /&gt;
        &lt;/span&gt;
    


Encryption is a topic that has fascinated me for years, less because of its mathematical basis than its applications, both existing and potential. By far my favourite project in this realm is &lt;a href=&#34;https://keybase.io&#34;&gt;Keybase&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Keybase cleverly solves several major problems with PGP-based encryption technology by taking the attitude that online, your identity is functionally the sum of your online profiles. With Keybase, you can automatically verify that &lt;a href=&#34;https://twitter.com/CJLaing&#34;&gt;@cjlaing&lt;/a&gt; on twitter has a particular key, and can encrypt messages or files for him without having to ascertain and validate his key through some other medium. The client software is open source, and works seamlessly with both PGP and NaCl keys.&lt;/p&gt;

&lt;p&gt;One of the truly excellent features of Keybase&amp;rsquo;s design is its trust model; although their website and file hosting service offers a centralised interface, that interface is entirely orthogonal to the operation of the service. When you want to id someone and verify their key (&lt;a href=&#34;https://keybase.io/chrislaing&#34;&gt;me, for example&lt;/a&gt;), the Keybase client goes to each of their listed web identities, finds the proof, and verifies it, without needing to trust the &lt;a href=&#34;https://keybase.io&#34;&gt;keybase.io&lt;/a&gt; website at all. Every time a user verifies someone&amp;rsquo;s identity by tracking them, this proof is written into the blockchain. The entire chain can then be independently verified, without requiring anyone to trust Keybase itself.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://keybase.io/docs/kbfs&#34;&gt;Keybase filesystem&lt;/a&gt; is an extremely clever extension of the core Keybase concept. What I find most interesting is the idea that, in principle, data can be securely shared with someone who hasn&amp;rsquo;t yet signed up for Keybase, whom you know purely through one of their online identities. When they join Keybase and prove their ownership of that identity, your client will verify the proof and encrypt the file for them.&lt;/p&gt;

&lt;p&gt;Keybase is still in an invitation-only testing phase, however they already have over 100,000 users as of the time of writing. The project is bringing a lot of great new ideas together with solid, tried, and tested cryptography, and I&amp;rsquo;m excited to see where the project goes next.&lt;/p&gt;

&lt;p&gt;In Part II of this post, we&amp;rsquo;ll take a look at how to verify Keybase proofs yourself, and traverse a user&amp;rsquo;s cryptographic chain using Python.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>